import { CustomNetwork, FormattedMultipleAccs, HandshakeWithSgx, AuthSig, JsonEncryptionRetrieveRequest, JsonSaveEncryptionKeyRequest, JsonSigningStoreRequest, JsonStoreSigningRequest, KV, LitNodeClientConfig, NodeCommandResponse, NodeCommandServerKeysResponse, RejectedNodePromises, SendNodeCommand, SuccessNodePromises, SupportedJsonRequests, SessionSigsMap, SessionSig } from '@lit-protocol/types';
export declare class LitCore {
    config: LitNodeClientConfig;
    connectedNodes: SetConstructor | Set<any> | any;
    serverKeys: KV | any;
    ready: boolean;
    subnetPubKey: string | null;
    networkPubKey: string | null;
    networkPubKeySet: string | null;
    constructor(args: any[LitNodeClientConfig | CustomNetwork | any]);
    /**
     *
     * Set bootstrapUrls to match the network litNetwork unless it's set to custom
     *
     * @returns { void }
     *
     */
    setCustomBootstrapUrls: () => void;
    /**
     *
     * Connect to the LIT nodes
     *
     * @returns { Promise } A promise that resolves when the nodes are connected.
     *
     */
    connect: () => Promise<any>;
    /**
     *
     * Get a random request ID
     *   *
     * @returns { string }
     *
     */
    getRequestId(): string;
    /**
     *
     * Handshake with SGX
     *
     * @param { HandshakeWithSgx } params
     *
     * @returns { Promise<NodeCommandServerKeysResponse> }
     *
     */
    handshakeWithSgx: (params: HandshakeWithSgx, requestId: string) => Promise<NodeCommandServerKeysResponse>;
    /**
     *
     * Send a command to nodes
     *
     * @param { SendNodeCommand }
     *
     * @returns { Promise<any> }
     *
     */
    sendCommandToNode: ({ url, data, requestId, }: SendNodeCommand) => Promise<any>;
    /**
     *
     * Securely save the association between access control conditions and something that you wish to decrypt
     *
     * @param { JsonSaveEncryptionKeyRequest } params
     *
     * @returns { Promise<Uint8Array> }
     *
     */
    saveEncryptionKey: (params: JsonSaveEncryptionKeyRequest) => Promise<Uint8Array>;
    /**
     *
     * Retrieve the symmetric encryption key from the LIT nodes.  Note that this will only work if the current user meets the access control conditions specified when the data was encrypted.  That access control condition is typically that the user is a holder of the NFT that corresponds to this encrypted data.  This NFT token address and ID was specified when this LIT was created.
     *
     */
    getEncryptionKey: (params: JsonEncryptionRetrieveRequest) => Promise<Uint8Array>;
    /**
     *
     * Get and gather node promises
     *
     * @param { any } callback
     *
     * @returns { Array<Promise<any>> }
     *
     */
    getNodePromises: (callback: Function) => Array<Promise<any>>;
    /**
     *
     * Get either auth sig or session auth sig
     *
     */
    getAuthSigOrSessionAuthSig: ({ authSig, sessionSigs, url, }: {
        authSig?: AuthSig | undefined;
        sessionSigs?: SessionSigsMap | undefined;
        url: string;
    }) => AuthSig | SessionSig;
    /**
     *
     * Get hash of access control conditions
     *
     * @param { JsonStoreSigningRequest } params
     *
     * @returns { Promise<ArrayBuffer | undefined> }
     *
     */
    getHashedAccessControlConditions: (params: JsonStoreSigningRequest) => Promise<ArrayBuffer | undefined>;
    /**
     *
     * Store encryption conditions to nodes
     *
     * @param { string } urk
     * @param { JsonEncryptionStoreRequest } params
     *
     * @returns { Promise<NodeCommandResponse> }
     *
     */
    storeEncryptionConditionWithNode: (url: string, params: JsonSigningStoreRequest, requestId: string) => Promise<NodeCommandResponse>;
    /**
     * Handle node promises
     *
     * @param { Array<Promise<any>> } nodePromises
     *
     * @returns { Promise<SuccessNodePromises | RejectedNodePromises> }
     *
     */
    handleNodePromises: (nodePromises: Array<Promise<any>>, minNodeCount?: number) => Promise<SuccessNodePromises | RejectedNodePromises>;
    /**
     *
     * Throw node error
     *
     * @param { RejectedNodePromises } res
     *
     * @returns { void }
     *
     */
    _throwNodeError: (res: RejectedNodePromises) => void;
    /**
     *
     * Get different formats of access control conditions, eg. evm, sol, unified etc.
     *
     * @param { SupportedJsonRequests } params
     *
     * @returns { FormattedMultipleAccs }
     *
     */
    getFormattedAccessControlConditions: (params: SupportedJsonRequests) => FormattedMultipleAccs;
    /**
     *
     * Ger Decryption Shares from Nodes
     *
     * @param { string } url
     * @param { JsonEncryptionRetrieveRequest } params
     *
     * @returns { Promise<any> }
     *
     */
    getDecryptionShare: (url: string, params: JsonEncryptionRetrieveRequest, requestId: string) => Promise<NodeCommandResponse>;
}
