"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LitCore = void 0;
const access_control_conditions_1 = require("@lit-protocol/access-control-conditions");
const bls_sdk_1 = require("@lit-protocol/bls-sdk");
const constants_1 = require("@lit-protocol/constants");
const crypto_1 = require("@lit-protocol/crypto");
const misc_1 = require("@lit-protocol/misc");
const uint8arrays_1 = require("@lit-protocol/uint8arrays");
class LitCore {
    // ========== Constructor ==========
    constructor(args) {
        // ========== Scoped Class Helpers ==========
        /**
         *
         * Set bootstrapUrls to match the network litNetwork unless it's set to custom
         *
         * @returns { void }
         *
         */
        this.setCustomBootstrapUrls = () => {
            // -- validate
            if (this.config.litNetwork === 'custom')
                return;
            // -- execute
            const hasNetwork = this.config.litNetwork in constants_1.LIT_NETWORKS;
            if (!hasNetwork) {
                // network not found, report error
                (0, misc_1.throwError)({
                    message: 'the litNetwork specified in the LitNodeClient config not found in LIT_NETWORKS',
                    errorKind: constants_1.LIT_ERROR.LIT_NODE_CLIENT_BAD_CONFIG_ERROR.kind,
                    errorCode: constants_1.LIT_ERROR.LIT_NODE_CLIENT_BAD_CONFIG_ERROR.name,
                });
                return;
            }
            this.config.bootstrapUrls = constants_1.LIT_NETWORKS[this.config.litNetwork];
        };
        /**
         *
         * Connect to the LIT nodes
         *
         * @returns { Promise } A promise that resolves when the nodes are connected.
         *
         */
        this.connect = () => {
            // -- handshake with each node
            const requestId = this.getRequestId();
            for (const url of this.config.bootstrapUrls) {
                this.handshakeWithSgx({ url }, requestId)
                    .then((resp) => {
                    this.connectedNodes.add(url);
                    let keys = {
                        serverPubKey: resp.serverPublicKey,
                        subnetPubKey: resp.subnetPublicKey,
                        networkPubKey: resp.networkPublicKey,
                        networkPubKeySet: resp.networkPublicKeySet,
                    };
                    // -- validate returned keys
                    if (keys.serverPubKey === 'ERR' ||
                        keys.subnetPubKey === 'ERR' ||
                        keys.networkPubKey === 'ERR' ||
                        keys.networkPubKeySet === 'ERR') {
                        (0, misc_1.log)('Error connecting to node. Detected "ERR" in keys', url, keys);
                    }
                    this.serverKeys[url] = keys;
                })
                    .catch((e) => {
                    (0, misc_1.log)('Error connecting to node ', url, e);
                });
            }
            // -- get promise
            const promise = new Promise((resolve, reject) => {
                const startTime = Date.now();
                const interval = setInterval(() => {
                    if (Object.keys(this.serverKeys).length >= this.config.minNodeCount) {
                        clearInterval(interval);
                        // pick the most common public keys for the subnet and network from the bunch, in case some evil node returned a bad key
                        this.subnetPubKey = (0, misc_1.mostCommonString)(Object.values(this.serverKeys).map((keysFromSingleNode) => keysFromSingleNode.subnetPubKey));
                        this.networkPubKey = (0, misc_1.mostCommonString)(Object.values(this.serverKeys).map((keysFromSingleNode) => keysFromSingleNode.networkPubKey));
                        this.networkPubKeySet = (0, misc_1.mostCommonString)(Object.values(this.serverKeys).map((keysFromSingleNode) => keysFromSingleNode.networkPubKeySet));
                        this.ready = true;
                        (0, misc_1.log)(`ðŸ”¥ lit is ready. "litNodeClient" variable is ready to use globally.`);
                        // @ts-ignore
                        globalThis.litNodeClient = this;
                        // browser only
                        if ((0, misc_1.isBrowser)()) {
                            document.dispatchEvent(new Event('lit-ready'));
                        }
                        // @ts-ignore: Expected 1 arguments, but got 0. Did you forget to include 'void' in your type argument to 'Promise'?ts(2794)
                        resolve();
                    }
                    else {
                        const now = Date.now();
                        if (now - startTime > this.config.connectTimeout) {
                            clearInterval(interval);
                            const msg = `Error: Could not connect to enough nodes after timeout of ${this.config.connectTimeout}ms.  Could only connect to ${Object.keys(this.serverKeys).length} of ${this.config.minNodeCount} required nodes.  Please check your network connection and try again.  Note that you can control this timeout with the connectTimeout config option which takes milliseconds.`;
                            (0, misc_1.log)(msg);
                            reject(msg);
                        }
                    }
                }, 500);
            });
            return promise;
        };
        /**
         *
         * Handshake with SGX
         *
         * @param { HandshakeWithSgx } params
         *
         * @returns { Promise<NodeCommandServerKeysResponse> }
         *
         */
        this.handshakeWithSgx = async (params, requestId) => {
            // -- get properties from params
            const { url } = params;
            // -- create url with path
            const urlWithPath = `${url}/web/handshake`;
            (0, misc_1.log)(`handshakeWithSgx ${urlWithPath}`);
            const data = {
                clientPublicKey: 'test',
            };
            return this.sendCommandToNode({
                url: urlWithPath,
                data,
                requestId,
            });
        };
        // ==================== SENDING COMMAND ====================
        /**
         *
         * Send a command to nodes
         *
         * @param { SendNodeCommand }
         *
         * @returns { Promise<any> }
         *
         */
        this.sendCommandToNode = async ({ url, data, requestId, }) => {
            (0, misc_1.log)(`sendCommandToNode with url ${url} and data`, data);
            const req = {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Lit-SDK-Version': constants_1.version,
                    'X-Lit-SDK-Type': 'Typescript',
                    'X-Request-Id': 'lit_' + requestId,
                },
                body: JSON.stringify(data),
            };
            return fetch(url, req)
                .then(async (response) => {
                const isJson = response.headers
                    .get('content-type')
                    ?.includes('application/json');
                const data = isJson ? await response.json() : null;
                if (!response.ok) {
                    // get error message from body or default to response status
                    const error = data || response.status;
                    return Promise.reject(error);
                }
                return data;
            })
                .catch((error) => {
                return Promise.reject(error);
            });
        };
        /**
         *
         * Securely save the association between access control conditions and something that you wish to decrypt
         *
         * @param { JsonSaveEncryptionKeyRequest } params
         *
         * @returns { Promise<Uint8Array> }
         *
         */
        this.saveEncryptionKey = async (params) => {
            // ========= Prepare Params ==========
            const { encryptedSymmetricKey, symmetricKey, authSig, chain, permanent } = params;
            // ========== Validate Params ==========
            // -- validate if it's ready
            if (!this.ready) {
                const message = '6 LitNodeClient is not ready.  Please call await litNodeClient.connect() first.';
                (0, misc_1.throwError)({
                    message,
                    errorKind: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.kind,
                    errorCode: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.name,
                });
            }
            // -- validate if this.subnetPubKey is null
            if (!this.subnetPubKey) {
                const message = 'subnetPubKey cannot be null';
                return (0, misc_1.throwError)({
                    message,
                    errorKind: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.kind,
                    errorCode: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.name,
                });
            }
            const paramsIsSafe = saveEncryptionKeyParamsIsSafe(params);
            if (!paramsIsSafe) {
                return (0, misc_1.throwError)({
                    message: `You must provide either accessControlConditions or evmContractConditions or solRpcConditions or unifiedAccessControlConditions`,
                    errorKind: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
                    errorCode: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name,
                });
            }
            // ========== Encryption ==========
            // -- encrypt with network pubkey
            let encryptedKey;
            if (encryptedSymmetricKey) {
                encryptedKey = encryptedSymmetricKey;
            }
            else {
                encryptedKey = bls_sdk_1.wasmBlsSdkHelpers.encrypt((0, uint8arrays_1.uint8arrayFromString)(this.subnetPubKey, 'base16'), symmetricKey);
                (0, misc_1.log)('symmetric key encrypted with LIT network key: ', (0, uint8arrays_1.uint8arrayToString)(encryptedKey, 'base16'));
            }
            // ========== Hashing ==========
            // -- hash the encrypted pubkey
            const hashOfKey = await crypto.subtle.digest('SHA-256', encryptedKey);
            const hashOfKeyStr = (0, uint8arrays_1.uint8arrayToString)(new Uint8Array(hashOfKey), 'base16');
            // hash the access control conditions
            let hashOfConditions = await this.getHashedAccessControlConditions(params);
            if (!hashOfConditions) {
                return (0, misc_1.throwError)({
                    message: `You must provide either accessControlConditions or evmContractConditions or solRpcConditions or unifiedAccessControlConditions`,
                    errorKind: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
                    errorCode: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name,
                });
            }
            const hashOfConditionsStr = (0, uint8arrays_1.uint8arrayToString)(new Uint8Array(hashOfConditions), 'base16');
            // ========== Node Promises ==========
            const requestId = this.getRequestId();
            const nodePromises = this.getNodePromises((url) => {
                // -- choose the right signature
                let sigToPassToNode = this.getAuthSigOrSessionAuthSig({
                    authSig: params.authSig,
                    sessionSigs: params.sessionSigs,
                    url,
                });
                return this.storeEncryptionConditionWithNode(url, {
                    key: hashOfKeyStr,
                    val: hashOfConditionsStr,
                    authSig: sigToPassToNode,
                    chain,
                    permanent: permanent ? 1 : 0,
                }, requestId);
            });
            // -- resolve promises
            const res = await this.handleNodePromises(nodePromises);
            // -- case: promises rejected
            if (res.success === false) {
                this._throwNodeError(res);
            }
            return encryptedKey;
        };
        /**
         *
         * Retrieve the symmetric encryption key from the LIT nodes.  Note that this will only work if the current user meets the access control conditions specified when the data was encrypted.  That access control condition is typically that the user is a holder of the NFT that corresponds to this encrypted data.  This NFT token address and ID was specified when this LIT was created.
         *
         */
        this.getEncryptionKey = async (params) => {
            // -- validate if it's ready
            if (!this.ready) {
                const message = '5 LitNodeClient is not ready.  Please call await litNodeClient.connect() first.';
                (0, misc_1.throwError)({
                    message,
                    errorKind: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.kind,
                    errorCode: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.name,
                });
            }
            // -- validate if this.networkPubKeySet is null
            if (!this.networkPubKeySet) {
                const message = 'networkPubKeySet cannot be null';
                (0, misc_1.throwError)({
                    message,
                    errorKind: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.kind,
                    errorCode: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.name,
                });
            }
            // ========== Prepare Params ==========
            const { chain, authSig, resourceId, toDecrypt } = params;
            // ========== Validate Params ==========
            const paramsIsSafe = getEncryptionKeyParamsIsSafe(params);
            if (!paramsIsSafe) {
                (0, misc_1.throwError)({
                    message: `You must provide either accessControlConditions or evmContractConditions or solRpcConditions or unifiedAccessControlConditions`,
                    errorKind: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
                    errorCode: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name,
                });
            }
            // ========== Formatting Access Control Conditions =========
            const { error, formattedAccessControlConditions, formattedEVMContractConditions, formattedSolRpcConditions, formattedUnifiedAccessControlConditions, } = this.getFormattedAccessControlConditions(params);
            if (error) {
                (0, misc_1.throwError)({
                    message: `You must provide either accessControlConditions or evmContractConditions or solRpcConditions or unifiedAccessControlConditions`,
                    errorKind: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
                    errorCode: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name,
                });
            }
            // ========== Node Promises ==========
            const requestId = this.getRequestId();
            const nodePromises = this.getNodePromises((url) => {
                // -- choose the right signature
                let sigToPassToNode = this.getAuthSigOrSessionAuthSig({
                    authSig: params.authSig,
                    sessionSigs: params.sessionSigs,
                    url,
                });
                return this.getDecryptionShare(url, {
                    accessControlConditions: formattedAccessControlConditions,
                    evmContractConditions: formattedEVMContractConditions,
                    solRpcConditions: formattedSolRpcConditions,
                    unifiedAccessControlConditions: formattedUnifiedAccessControlConditions,
                    toDecrypt,
                    authSig: sigToPassToNode,
                    chain,
                }, requestId);
            });
            // -- resolve promises
            const res = await this.handleNodePromises(nodePromises);
            // -- case: promises rejected
            if (res.success === false) {
                this._throwNodeError(res);
            }
            const decryptionShares = res
                .values;
            (0, misc_1.log)('decryptionShares', decryptionShares);
            if (!this.networkPubKeySet) {
                return (0, misc_1.throwError)({
                    message: 'networkPubKeySet cannot be null',
                    errorKind: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.kind,
                    errorCode: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.name,
                });
            }
            // ========== Combine Shares ==========
            const decrypted = (0, crypto_1.combineBlsDecryptionShares)(decryptionShares, this.networkPubKeySet, toDecrypt);
            return decrypted;
        };
        /**
         *
         * Get and gather node promises
         *
         * @param { any } callback
         *
         * @returns { Array<Promise<any>> }
         *
         */
        this.getNodePromises = (callback) => {
            const nodePromises = [];
            for (const url of this.connectedNodes) {
                nodePromises.push(callback(url));
            }
            return nodePromises;
        };
        /**
         *
         * Get either auth sig or session auth sig
         *
         */
        this.getAuthSigOrSessionAuthSig = ({ authSig, sessionSigs, url, }) => {
            if (!authSig && !sessionSigs) {
                (0, misc_1.throwError)({
                    message: `You must pass either authSig or sessionSigs`,
                    errorKind: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
                    errorCode: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name,
                });
                // @ts-ignore
                return;
            }
            if (sessionSigs) {
                const sigToPassToNode = sessionSigs[url];
                if (!sigToPassToNode) {
                    (0, misc_1.throwError)({
                        message: `You passed sessionSigs but we could not find session sig for node ${url}`,
                        errorKind: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
                        errorCode: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name,
                    });
                }
                return sigToPassToNode;
            }
            return authSig;
        };
        /**
         *
         * Get hash of access control conditions
         *
         * @param { JsonStoreSigningRequest } params
         *
         * @returns { Promise<ArrayBuffer | undefined> }
         *
         */
        this.getHashedAccessControlConditions = async (params) => {
            let hashOfConditions;
            // ========== Prepare Params ==========
            const { accessControlConditions, evmContractConditions, solRpcConditions, unifiedAccessControlConditions, } = params;
            // ========== Hash ==========
            if (accessControlConditions) {
                hashOfConditions = await (0, access_control_conditions_1.hashAccessControlConditions)(accessControlConditions);
            }
            else if (evmContractConditions) {
                hashOfConditions = await (0, access_control_conditions_1.hashEVMContractConditions)(evmContractConditions);
            }
            else if (solRpcConditions) {
                hashOfConditions = await (0, access_control_conditions_1.hashSolRpcConditions)(solRpcConditions);
            }
            else if (unifiedAccessControlConditions) {
                hashOfConditions = await (0, access_control_conditions_1.hashUnifiedAccessControlConditions)(unifiedAccessControlConditions);
            }
            else {
                return;
            }
            // ========== Result ==========
            return hashOfConditions;
        };
        /**
         *
         * Store encryption conditions to nodes
         *
         * @param { string } urk
         * @param { JsonEncryptionStoreRequest } params
         *
         * @returns { Promise<NodeCommandResponse> }
         *
         */
        this.storeEncryptionConditionWithNode = async (url, params, requestId) => {
            (0, misc_1.log)('storeEncryptionConditionWithNode');
            const urlWithPath = `${url}/web/encryption/store`;
            const data = {
                key: params.key,
                val: params.val,
                authSig: params.authSig,
                chain: params.chain,
                permanant: params.permanent,
            };
            return await this.sendCommandToNode({ url: urlWithPath, data, requestId });
        };
        /**
         * Handle node promises
         *
         * @param { Array<Promise<any>> } nodePromises
         *
         * @returns { Promise<SuccessNodePromises | RejectedNodePromises> }
         *
         */
        this.handleNodePromises = async (nodePromises, minNodeCount) => {
            // -- prepare
            const responses = await Promise.allSettled(nodePromises);
            const minNodes = minNodeCount ?? this.config.minNodeCount;
            // -- get fulfilled responses
            const successes = responses.filter((r) => r.status === 'fulfilled');
            // -- case: success (when success responses are more than minNodeCount)
            if (successes.length >= minNodes) {
                const successPromises = {
                    success: true,
                    values: successes.map((r) => r.value),
                };
                return successPromises;
            }
            // -- case: if we're here, then we did not succeed.  time to handle and report errors.
            // -- get "rejected" responses
            const rejected = responses.filter((r) => r.status === 'rejected');
            const mostCommonError = JSON.parse((0, misc_1.mostCommonString)(rejected.map((r) => JSON.stringify(r.reason))));
            (0, misc_1.log)(`most common error: ${JSON.stringify(mostCommonError)}`);
            const rejectedPromises = {
                success: false,
                error: mostCommonError,
            };
            return rejectedPromises;
        };
        /**
         *
         * Throw node error
         *
         * @param { RejectedNodePromises } res
         *
         * @returns { void }
         *
         */
        this._throwNodeError = (res) => {
            if (res.error && res.error.errorCode) {
                if ((res.error.errorCode === constants_1.LIT_ERROR_CODE.NODE_NOT_AUTHORIZED ||
                    res.error.errorCode === 'not_authorized') &&
                    this.config.alertWhenUnauthorized) {
                    (0, misc_1.log)('[Alert originally] You are not authorized to access to this content');
                }
                (0, misc_1.throwError)({
                    ...res.error,
                    message: res.error.message ||
                        'You are not authorized to access to this content',
                    errorCode: res.error.errorCode,
                });
            }
            else {
                (0, misc_1.throwError)({
                    message: `There was an error getting the signing shares from the nodes`,
                    error: constants_1.LIT_ERROR.UNKNOWN_ERROR,
                });
            }
        };
        /**
         *
         * Get different formats of access control conditions, eg. evm, sol, unified etc.
         *
         * @param { SupportedJsonRequests } params
         *
         * @returns { FormattedMultipleAccs }
         *
         */
        this.getFormattedAccessControlConditions = (params) => {
            // -- prepare params
            const { accessControlConditions, evmContractConditions, solRpcConditions, unifiedAccessControlConditions, } = params;
            // -- execute
            let formattedAccessControlConditions;
            let formattedEVMContractConditions;
            let formattedSolRpcConditions;
            let formattedUnifiedAccessControlConditions;
            let error = false;
            if (accessControlConditions) {
                formattedAccessControlConditions = accessControlConditions.map((c) => (0, access_control_conditions_1.canonicalAccessControlConditionFormatter)(c));
                (0, misc_1.log)('formattedAccessControlConditions', JSON.stringify(formattedAccessControlConditions));
            }
            else if (evmContractConditions) {
                formattedEVMContractConditions = evmContractConditions.map((c) => (0, access_control_conditions_1.canonicalEVMContractConditionFormatter)(c));
                (0, misc_1.log)('formattedEVMContractConditions', JSON.stringify(formattedEVMContractConditions));
            }
            else if (solRpcConditions) {
                formattedSolRpcConditions = solRpcConditions.map((c) => (0, access_control_conditions_1.canonicalSolRpcConditionFormatter)(c));
                (0, misc_1.log)('formattedSolRpcConditions', JSON.stringify(formattedSolRpcConditions));
            }
            else if (unifiedAccessControlConditions) {
                formattedUnifiedAccessControlConditions =
                    unifiedAccessControlConditions.map((c) => (0, access_control_conditions_1.canonicalUnifiedAccessControlConditionFormatter)(c));
                (0, misc_1.log)('formattedUnifiedAccessControlConditions', JSON.stringify(formattedUnifiedAccessControlConditions));
            }
            else {
                error = true;
            }
            return {
                error,
                formattedAccessControlConditions,
                formattedEVMContractConditions,
                formattedSolRpcConditions,
                formattedUnifiedAccessControlConditions,
            };
        };
        /**
         *
         * Ger Decryption Shares from Nodes
         *
         * @param { string } url
         * @param { JsonEncryptionRetrieveRequest } params
         *
         * @returns { Promise<any> }
         *
         */
        this.getDecryptionShare = async (url, params, requestId) => {
            (0, misc_1.log)('getDecryptionShare');
            const urlWithPath = `${url}/web/encryption/retrieve`;
            return await this.sendCommandToNode({
                url: urlWithPath,
                data: params,
                requestId,
            });
        };
        let customConfig = args;
        // -- initialize default config
        this.config = constants_1.defaultLitnodeClientConfig;
        // -- initialize default auth callback
        // this.defaultAuthCallback = args?.defaultAuthCallback;
        // -- if config params are specified, replace it
        if (customConfig) {
            this.config = { ...this.config, ...customConfig };
            // this.config = override(this.config, customConfig);
        }
        // -- init default properties
        this.connectedNodes = new Set();
        this.serverKeys = {};
        this.ready = false;
        this.subnetPubKey = null;
        this.networkPubKey = null;
        this.networkPubKeySet = null;
        // -- set bootstrapUrls to match the network litNetwork unless it's set to custom
        this.setCustomBootstrapUrls();
        // -- set global variables
        globalThis.litConfig = this.config;
    }
    /**
     *
     * Get a random request ID
     *   *
     * @returns { string }
     *
     */
    getRequestId() {
        return Math.random().toString(16).slice(2);
    }
}
exports.LitCore = LitCore;
function saveEncryptionKeyParamsIsSafe(params) {
    // -- prepare params
    const { accessControlConditions, evmContractConditions, solRpcConditions, unifiedAccessControlConditions, authSig, chain, symmetricKey, encryptedSymmetricKey, permanant, permanent, sessionSigs, } = params;
    if (accessControlConditions &&
        !(0, misc_1.is)(accessControlConditions, 'Array', 'accessControlConditions', 'saveEncryptionKey'))
        return false;
    if (evmContractConditions &&
        !(0, misc_1.is)(evmContractConditions, 'Array', 'evmContractConditions', 'saveEncryptionKey'))
        return false;
    if (solRpcConditions &&
        !(0, misc_1.is)(solRpcConditions, 'Array', 'solRpcConditions', 'saveEncryptionKey'))
        return false;
    if (unifiedAccessControlConditions &&
        !(0, misc_1.is)(unifiedAccessControlConditions, 'Array', 'unifiedAccessControlConditions', 'saveEncryptionKey'))
        return false;
    // log('authSig:', authSig);
    if (authSig && !(0, misc_1.is)(authSig, 'Object', 'authSig', 'saveEncryptionKey'))
        return false;
    if (authSig &&
        !(0, misc_1.checkIfAuthSigRequiresChainParam)(authSig, chain, 'saveEncryptionKey'))
        return false;
    if (sessionSigs &&
        !(0, misc_1.is)(sessionSigs, 'Object', 'sessionSigs', 'saveEncryptionKey'))
        return false;
    if (!sessionSigs && !authSig) {
        (0, misc_1.throwError)({
            message: 'You must pass either authSig or sessionSigs',
            errorKind: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
            errorCode: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name,
        });
        return false;
    }
    if (symmetricKey &&
        !(0, misc_1.is)(symmetricKey, 'Uint8Array', 'symmetricKey', 'saveEncryptionKey'))
        return false;
    if (encryptedSymmetricKey &&
        !(0, misc_1.is)(encryptedSymmetricKey, 'Uint8Array', 'encryptedSymmetricKey', 'saveEncryptionKey'))
        return false;
    // to fix spelling mistake
    if (typeof params.permanant !== 'undefined') {
        params.permanent = params.permanant;
    }
    if ((!symmetricKey || symmetricKey == '') &&
        (!encryptedSymmetricKey || encryptedSymmetricKey == '')) {
        throw new Error('symmetricKey and encryptedSymmetricKey are blank.  You must pass one or the other');
    }
    if (!accessControlConditions &&
        !evmContractConditions &&
        !solRpcConditions &&
        !unifiedAccessControlConditions) {
        throw new Error('accessControlConditions and evmContractConditions and solRpcConditions and unifiedAccessControlConditions are blank');
    }
    // -- validate: if sessionSig and authSig exists
    if (sessionSigs && authSig) {
        (0, misc_1.throwError)({
            message: 'You must pass only one authSig or sessionSigs',
            errorKind: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
            errorCode: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name,
        });
        return false;
    }
    //   -- case: success
    return true;
}
function getEncryptionKeyParamsIsSafe(params) {
    const { accessControlConditions, evmContractConditions, solRpcConditions, unifiedAccessControlConditions, toDecrypt, authSig, chain, sessionSigs, } = params;
    // -- validate
    if (accessControlConditions &&
        !(0, misc_1.is)(accessControlConditions, 'Array', 'accessControlConditions', 'getEncryptionKey'))
        return false;
    if (evmContractConditions &&
        !(0, misc_1.is)(evmContractConditions, 'Array', 'evmContractConditions', 'getEncryptionKey'))
        return false;
    if (solRpcConditions &&
        !(0, misc_1.is)(solRpcConditions, 'Array', 'solRpcConditions', 'getEncryptionKey'))
        return false;
    if (unifiedAccessControlConditions &&
        !(0, misc_1.is)(unifiedAccessControlConditions, 'Array', 'unifiedAccessControlConditions', 'getEncryptionKey'))
        return false;
    (0, misc_1.log)('TYPEOF toDecrypt in getEncryptionKey():', typeof toDecrypt);
    if (!(0, misc_1.is)(toDecrypt, 'String', 'toDecrypt', 'getEncryptionKey'))
        return false;
    if (authSig && !(0, misc_1.is)(authSig, 'Object', 'authSig', 'getEncryptionKey'))
        return false;
    if (sessionSigs &&
        !(0, misc_1.is)(sessionSigs, 'Object', 'sessionSigs', 'getEncryptionKey'))
        return false;
    // -- validate: if sessionSig or authSig exists
    if (!sessionSigs && !authSig) {
        (0, misc_1.throwError)({
            message: 'You must pass either authSig or sessionSigs',
            errorKind: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
            errorCode: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name,
        });
        return false;
    }
    // -- validate: if sessionSig and authSig exists
    if (sessionSigs && authSig) {
        (0, misc_1.throwError)({
            message: 'You must pass only one authSig or sessionSigs',
            errorKind: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
            errorCode: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name,
        });
        return false;
    }
    // -- validate if 'chain' is null
    if (!chain) {
        return false;
    }
    if (authSig &&
        !(0, misc_1.checkIfAuthSigRequiresChainParam)(authSig, chain, 'getEncryptionKey'))
        return false;
    return true;
}
//# sourceMappingURL=lit-core.js.map