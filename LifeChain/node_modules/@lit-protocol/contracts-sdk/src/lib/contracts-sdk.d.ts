import { ethers } from 'ethers';
import { hexToDec, decToHex } from './hex2dec';
import * as accessControlConditionsContract from '../abis/AccessControlConditions';
import * as allowlistContract from '../abis/Allowlist';
import * as contractResolverContract from '../abis/ContractResolver';
import * as litTokenContract from '../abis/LITToken';
import * as multisenderContract from '../abis/Multisender';
import * as pkpHelperContract from '../abis/PKPHelper';
import * as pkpNftContract from '../abis/PKPNFT';
import * as pkpPermissionsContract from '../abis/PKPPermissions';
import * as pubkeyRouterContract from '../abis/PubkeyRouter';
import * as rateLimitNftContract from '../abis/RateLimitNFT';
import * as stakingContract from '../abis/Staking';
import { TokenInfo } from './addresses';
export declare const asyncForEachReturn: (array: Array<any>, callback: Function) => Promise<any[]>;
export interface IPFSHash {
    digest: string;
    hashFunction: number;
    size: number;
}
declare global {
    interface Window {
        ethereum: any;
    }
}
export declare class LitContracts {
    provider: ethers.providers.JsonRpcProvider | any;
    rpc: string;
    rpcs: string[];
    signer: ethers.Signer | ethers.Wallet;
    privateKey: string | undefined;
    options?: {
        storeOrUseStorageKey?: boolean;
    };
    randomPrivateKey: boolean;
    connected: boolean;
    isPKP: boolean;
    debug: boolean;
    accessControlConditionsContract: {
        read: accessControlConditionsContract.ContractContext;
        write: accessControlConditionsContract.ContractContext;
    };
    allowlistContract: {
        read: allowlistContract.ContractContext;
        write: allowlistContract.ContractContext;
    };
    contractResolverContract: {
        read: contractResolverContract.ContractContext;
        write: contractResolverContract.ContractContext;
    };
    litTokenContract: {
        read: litTokenContract.ContractContext;
        write: litTokenContract.ContractContext;
    };
    multisenderContract: {
        read: multisenderContract.ContractContext;
        write: multisenderContract.ContractContext;
    };
    pkpHelperContract: {
        read: pkpHelperContract.ContractContext;
        write: pkpHelperContract.ContractContext;
    };
    pkpNftContract: {
        read: pkpNftContract.ContractContext;
        write: pkpNftContract.ContractContext;
    };
    pkpPermissionsContract: {
        read: pkpPermissionsContract.ContractContext;
        write: pkpPermissionsContract.ContractContext;
    };
    pubkeyRouterContract: {
        read: pubkeyRouterContract.ContractContext;
        write: pubkeyRouterContract.ContractContext;
    };
    rateLimitNftContract: {
        read: rateLimitNftContract.ContractContext;
        write: rateLimitNftContract.ContractContext;
    };
    stakingContract: {
        read: stakingContract.ContractContext;
        write: stakingContract.ContractContext;
    };
    constructor(args?: {
        provider?: ethers.providers.JsonRpcProvider | any;
        rpcs?: string[] | any;
        rpc?: string | any;
        signer?: ethers.Signer | any;
        privateKey?: string | undefined;
        randomPrivatekey?: boolean;
        options?: {
            storeOrUseStorageKey?: boolean;
        };
        debug?: boolean;
    });
    /**
     * Logs a message to the console.
     *
     * @param {string} str The message to log.
     * @param {any} [opt] An optional value to log with the message.
     */
    log: (str: string, opt?: any) => void;
    connect: () => Promise<void>;
    utils: {
        hexToDec: typeof hexToDec;
        decToHex: typeof decToHex;
        /**
         * Partition multihash string into object representing multihash
         *
         * @param {string} multihash A base58 encoded multihash string
         * @returns {Multihash}
         */
        getBytesFromMultihash: (multihash: string) => string;
        /**
         *
         * Convert bytes32 to IPFS ID
         * @param { string } byte32 0x1220baa0d1e91f2a22fef53659418ddc3ac92da2a76d994041b86ed62c0c999de477
         * @returns { string } QmZKLGf3vgYsboM7WVUS9X56cJSdLzQVacNp841wmEDRkW
         */
        getMultihashFromBytes: (byte32: string) => string;
        /**
         * Partition multihash string into object representing multihash
         *
         * @param {string} multihash A base58 encoded multihash string
         * @returns {Multihash}
         */
        getBytes32FromMultihash: (ipfsId: string) => IPFSHash;
        timestamp2Date: (timestamp: string) => string;
    };
    pkpNftContractUtil: {
        read: {
            /**
             * (IERC721Enumerable)
             *
             * Get all PKPs by a given address
             *
             * @param { string } ownerAddress
             * @retu
             * */
            getTokensByAddress: (ownerAddress: string) => Promise<Array<string>>;
            /**
             * (IERC721Enumerable)
             *
             * Get the x latest number of tokens
             *
             * @param { number } latestNumberOfTokens
             *
             * @returns { Array<string> } a list of PKP NFTs
             *
             */
            getTokens: (latestNumberOfTokens: number) => Promise<Array<string>>;
            /**
             * Get info of all PKPs by a given address
             */
            getTokensInfoByAddress: (ownerAddress: string) => Promise<Array<TokenInfo>>;
        };
        write: {
            mint: () => Promise<{
                tx: ethers.providers.TransactionResponse;
                tokenId: any;
                res: any;
            }>;
        };
    };
    pkpPermissionsContractUtil: {
        read: {
            /**
             *
             * Check if an address is permitted
             *
             * @param { string } tokenId
             * @param { string } address
             *
             * @returns { Promise<boolean> }
             */
            isPermittedAddress: (tokenId: string, address: string) => Promise<boolean>;
            getPermittedAddresses: (tokenId: string) => Promise<Array<string>>;
            /**
             *
             * Get permitted action
             *
             * @param { any } id
             *
             * @returns { Promise<Array<any>> }
             *
             */
            getPermittedActions: (tokenId: any) => Promise<Array<any>>;
            /**
             *
             * Check if an action is permitted given the pkpid and ipfsId
             *
             * @param { string } pkpId 103309008291725705563022469659474510532358692659842796086905702509072063991354
             * @param { string } ipfsId  QmZKLGf3vgYsboM7WVUS9X56cJSdLzQVacNp841wmEDRkW
             *
             * @return { object } transaction
             */
            isPermittedAction: (pkpId: string, ipfsId: string) => Promise<boolean>;
        };
        write: {
            /**
             *
             * Add permitted action to a given PKP id & ipfsId
             *
             * @param { string } pkpId 103309008291725705563022469659474510532358692659842796086905702509072063991354
             * @param { string } ipfsId  QmZKLGf3vgYsboM7WVUS9X56cJSdLzQVacNp841wmEDRkW
             *
             * @return { object } transaction
             */
            addPermittedAction: (pkpId: string, ipfsId: string) => Promise<any>;
            /**
             * TODO: add transaction type
             * Add permitted action to a given PKP id & ipfsId
             *
             * @param { string } pkpId 103309008291725705563022469659474510532358692659842796086905702509072063991354
             * @param { string } ownerAddress  0x3B5dD2605.....22aDC499A1
             *
             * @return { object } transaction
             */
            addPermittedAddress: (pkpId: string, ownerAddress: string) => Promise<any>;
            /**
             * Revoke permitted action of a given PKP id & ipfsId
             *
             * @param { string } pkpId 103309008291725705563022469659474510532358692659842796086905702509072063991354
             * @param { string } ipfsId  QmZKLGf3vgYsboM7WVUS9X56cJSdLzQVacNp841wmEDRkW
             *
             * @return { object } transaction
             */
            revokePermittedAction: (pkpId: string, ipfsId: string) => Promise<any>;
        };
    };
    rateLimitNftContractUtil: {
        read: {
            /**
             * getCapacityByIndex: async (index: number): Promise<any> => {
             *
             *  This function takes a token index as a parameter and returns the capacity of the token
             *  with the given index. The capacity is an object that contains the number of requests
             *  per millisecond that the token allows, and an object with the expiration timestamp and
             *  formatted expiration date of the token.
             *
             *  @param {number} index - The index of the token.
             *  @returns {Promise<any>} - A promise that resolves to the capacity of the token.
             *
             *  Example:
             *
             *  const capacity = await getCapacityByIndex(1);
             *  this.log(capacity);
             *  // Output: {
             *  //   requestsPerMillisecond: 100,
             *  //   expiresAt: {
             *  //     timestamp: 1623472800,
             *  //     formatted: '2022-12-31',
             *  //   },
             *  // }
             *
             * }
             */
            getCapacityByIndex: (index: number) => Promise<any>;
            /**
             * getTokenURIByIndex: async (index: number): Promise<string> => {
             *
             *  This function takes a token index as a parameter and returns the URI of the token
             *  with the given index.
             *
             *  @param {number} index - The index of the token.
             *  @returns {Promise<string>} - A promise that resolves to the URI of the token.
             *
             *  Example:
             *
             *  const URI = await getTokenURIByIndex(1);
             *  this.log(URI);
             *  // Output: 'https://tokens.com/1'
             *
             * }
             */
            getTokenURIByIndex: (index: number) => Promise<string>;
            /**
             * getTokensByOwnerAddress: async (ownerAddress: string): Promise<any> => {
             *
             *  This function takes an owner address as a parameter and returns an array of tokens
             *  that are owned by the given address.
             *
             *  @param {string} ownerAddress - The address of the owner.
             *  @returns {Promise<any>} - A promise that resolves to an array of token objects.
             *
             *  Example:
             *
             *  const tokens = await getTokensByOwnerAddress('0x1234...5678');
             *  this.log(tokens);
             *  // Output: [
             *  //   {
             *  //     tokenId: 1,
             *  //     URI: 'https://tokens.com/1',
             *  //     capacity: 100,
             *  //     isExpired: false,
             *  //   },
             *  //   {
             *  //     tokenId: 2,
             *  //     URI: 'https://tokens.com/2',
             *  //     capacity: 200,
             *  //     isExpired: true,
             *  //   },
             *  //   ...
             *  // ]
             *
             * }
             */
            getTokensByOwnerAddress: (ownerAddress: string) => Promise<any>;
            /**
             * getTokens: async (): Promise<any> => {
             *
             *  This function returns an array of all tokens that have been minted.
             *
             *  @returns {Promise<any>} - A promise that resolves to an array of token objects.
             *
             *  Example:
             *
             *  const tokens = await getTokens();
             *  this.log(tokens);
             *  // Output: [
             *  //   {
             *  //     tokenId: 1,
             *  //     URI: 'https://tokens.com/1',
             *  //     capacity: 100,
             *  //     isExpired: false,
             *  //   },
             *  //   {
             *  //     tokenId: 2,
             *  //     URI: 'https://tokens.com/2',
             *  //     capacity: 200,
             *  //     isExpired: true,
             *  //   },
             *  //   ...
             *  // ]
             *
             * }
             */
            getTokens: () => Promise<any>;
        };
        write: {
            mint: ({ mintCost, timestamp, }: {
                mintCost: {
                    value: any;
                };
                timestamp: number;
            }) => Promise<{
                tx: ethers.ContractTransaction & ethers.providers.TransactionRequest;
                tokenId: any;
            }>;
            /**
             * Transfer RLI token from one address to another
             *
             * @property { string } fromAddress
             * @property { string } toAddress
             * @property  { stsring } RLITokenAddress
             *
             * @return { <Promise<void> } void
             */
            transfer: ({ fromAddress, toAddress, RLITokenAddress, }: {
                fromAddress: string;
                toAddress: string;
                RLITokenAddress: string;
            }) => Promise<any>;
        };
    };
    routerContractUtil: {
        read: {};
        write: {};
    };
}
