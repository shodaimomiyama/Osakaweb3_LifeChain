import { CustomNetwork, ExecuteJsProps, ExecuteJsResponse, GetSessionSigsProps, GetSignSessionKeySharesProp, AuthSig, JsonExecutionRequest, JsonSignChainDataRequest, JsonSigningRetrieveRequest, JsonSigningStoreRequest, JsonStoreSigningRequest, LitNodeClientConfig, NodeCommandResponse, NodeShare, RejectedNodePromises, SessionKeyPair, SignedChainDataToken, SignSessionKeyProp, SignConditionECDSA, SuccessNodePromises, ValidateAndSignECDSA, AuthCallbackParams, WebAuthnAuthenticationVerificationParams, AuthMethod, SignSessionKeyResponse, GetWalletSigProps, SessionSigsMap, JsonPkpSignRequest } from '@lit-protocol/types';
import { ILitResource, ISessionCapabilityObject, LitResourceAbilityRequest } from '@lit-protocol/auth-helpers';
import { LitCore } from '@lit-protocol/core';
/** ---------- Main Export Class ---------- */
export declare class LitNodeClientNodeJs extends LitCore {
    #private;
    defaultAuthCallback?: (authSigParams: AuthCallbackParams) => Promise<AuthSig>;
    constructor(args: any[LitNodeClientConfig | CustomNetwork | any]);
    /**
     *
     * Get the request body of the lit action
     *
     * @param { ExecuteJsProps } params
     *
     * @returns { JsonExecutionRequest }
     *
     */
    getLitActionRequestBody: (params: ExecuteJsProps) => JsonExecutionRequest;
    /**
     *
     * we need to send jwt params iat (issued at) and exp (expiration) because the nodes may have different wall clock times, the nodes will verify that these params are withing a grace period
     *
     */
    getJWTParams: () => {
        iat: number;
        exp: number;
    };
    /**
     *
     * Parse the response string to JSON
     *
     * @param { string } responseString
     *
     * @returns { any } JSON object
     *
     */
    parseResponses: (responseString: string) => any;
    /**
     * Try to get the session key in the local storage,
     * if not, generates one.
     * @return { SessionKeyPair } session key pair
     */
    getSessionKey: () => SessionKeyPair;
    /**
     * Check if a given object is of type SessionKeyPair.
     *
     * @param obj - The object to check.
     * @returns True if the object is of type SessionKeyPair.
     */
    isSessionKeyPair(obj: any): obj is SessionKeyPair;
    /**
     * Generates wildcard capability for each of the LIT resources
     * specified.
     * @param litResources is an array of LIT resources
     */
    generateSessionCapabilityObjectWithWildcards: (litResources: Array<ILitResource>) => ISessionCapabilityObject;
    /**
     *
     * Get expiration for session
     *
     */
    getExpiration: () => string;
    /**
     *
     * Get the signature from local storage, if not, generates one
     *
     */
    getWalletSig: ({ authNeededCallback, chain, sessionCapabilityObject, switchChain, expiration, sessionKeyUri, }: GetWalletSigProps) => Promise<AuthSig>;
    /**
     *
     * Check if a session key needs to be resigned. These are the scenarios where a session key needs to be resigned:
     * 1. The authSig.sig does not verify successfully against the authSig.signedMessage
     * 2. The authSig.signedMessage.uri does not match the sessionKeyUri
     * 3. The authSig.signedMessage does not contain at least one session capability object
     *
     */
    checkNeedToResignSessionKey: ({ authSig, sessionKeyUri, resourceAbilityRequests, }: {
        authSig: AuthSig;
        sessionKeyUri: any;
        resourceAbilityRequests: Array<LitResourceAbilityRequest>;
    }) => Promise<boolean>;
    /**
     *
     * Get JS Execution Shares from Nodes
     *
     * @param { JsonExecutionRequest } params
     *
     * @returns { Promise<any> }
     */
    getJsExecutionShares: (url: string, params: JsonExecutionRequest, requestId: string) => Promise<NodeCommandResponse>;
    getPkpSignExecutionShares: (url: string, params: any, requestId: string) => Promise<any>;
    /**
     *
     * Get Chain Data Signing Shares
     *
     * @param { string } url
     * @param { JsonSignChainDataRequest } params
     *
     * @returns { Promise<any> }
     *
     */
    getChainDataSigningShare: (url: string, params: JsonSignChainDataRequest, requestId: string) => Promise<NodeCommandResponse>;
    /**
     *
     * Get Signing Shares from Nodes
     *
     * @param { string } url
     * @param { JsonSigningRetrieveRequest } params
     *
     * @returns { Promise<any>}
     *
     */
    getSigningShare: (url: string, params: JsonSigningRetrieveRequest, requestId: string) => Promise<NodeCommandResponse>;
    /**
     *
     * Store signing conditions to nodes
     *
     * @param { string } url
     * @param { JsonSigningStoreRequest } params
     *
     * @returns { Promise<NodeCommandResponse> }
     *
     */
    storeSigningConditionWithNode: (url: string, params: JsonSigningStoreRequest, requestId: string) => Promise<NodeCommandResponse>;
    /**
     *
     * Sign Condition ECDSA
     *
     * @param { string } url
     * @param { SignConditionECDSA } params
     *
     * @returns { Promise<NodeCommandResponse> }
     *
     */
    signConditionEcdsa: (url: string, params: SignConditionECDSA, requestId: string) => Promise<NodeCommandResponse>;
    /**
     *
     * Combine Shares from network public key set and signature shares
     *
     * @param { string } networkPubKeySet
     * @param { any } signatureShares
     *
     * @returns { string } final JWT (convert the sig to base64 and append to the jwt)
     *
     */
    combineSharesAndGetJWT: (networkPubKeySet: string, signatureShares: Array<NodeShare>) => string;
    /**
     * Run lit action on a single deterministicly selected node. It's important that the nodes use the same deterministic selection algorithm.
     *
     * @param { ExecuteJsProps } params
     *
     * @returns { Promise<SuccessNodePromises | RejectedNodePromises> }
     *
     */
    runOnTargetedNodes: (params: ExecuteJsProps) => Promise<SuccessNodePromises | RejectedNodePromises>;
    /**
     *
     * Get signatures from signed data
     *
     * @param { Array<any> } signedData
     *
     * @returns { any }
     *
     */
    getSessionSignatures: (signedData: Array<any>) => any;
    /**
     *
     * Get signatures from signed data
     *
     * @param { Array<any> } signedData
     *
     * @returns { any }
     *
     */
    getSignatures: (signedData: Array<any>) => any;
    /**
     *
     * Get the decryptions from the decrypted data list
     *
     * @param { Array<any> } decryptedData
     *
     * @returns { Promise<Array<any>> }
     *
     */
    getDecryptions: (decryptedData: Array<any>) => Promise<Array<any>>;
    /**
     *
     * Get a single signature
     *
     * @param { Array<any> } shareData from all node promises
     *
     * @returns { string } signature
     *
     */
    getSignature: (shareData: Array<any>) => Promise<any>;
    /**
     *
     * Execute JS on the nodes and combine and return any resulting signatures
     *
     * @param { ExecuteJsRequest } params
     *
     * @returns { ExecuteJsResponse }
     *
     */
    executeJs: (params: ExecuteJsProps) => Promise<ExecuteJsResponse>;
    pkpSign: (params: JsonPkpSignRequest) => Promise<any>;
    /**
     *
     * Request a signed JWT of any solidity function call from the LIT network.  There are no prerequisites for this function.  You should use this function if you need to transmit information across chains, or from a blockchain to a centralized DB or server.  The signature of the returned JWT verifies that the response is genuine.
     *
     * @param { SignedChainDataToken } params
     *
     * @returns { Promise<string>}
     */
    getSignedChainDataToken: (params: SignedChainDataToken) => Promise<string>;
    /**
     *
     * Request a signed JWT from the LIT network. Before calling this function, you must either create or know of a resource id and access control conditions for the item you wish to gain authorization for. You can create an access control condition using the saveSigningCondition function.
     *
     * @param { JsonSigningRetrieveRequest } params
     *
     * @returns { Promise<string> } final JWT
     *
     */
    getSignedToken: (params: JsonSigningRetrieveRequest) => Promise<string>;
    /**
     *
     * Associated access control conditions with a resource on the web.  After calling this function, users may use the getSignedToken function to request a signed JWT from the LIT network.  This JWT proves that the user meets the access control conditions, and is authorized to access the resource you specified in the resourceId parameter of the saveSigningCondition function.
     *
     * @param { JsonStoreSigningRequest } params
     *
     * @returns { Promise<boolean> }
     *
     */
    saveSigningCondition: (params: JsonStoreSigningRequest) => Promise<boolean>;
    /**
     *
     * Validates a condition, and then signs the condition if the validation returns true.
     * Before calling this function, you must know the on chain conditions that you wish to validate.
     *
     * @param { ValidateAndSignECDSA } params
     *
     * @returns { Promise<string> }
     */
    validateAndSignEcdsa: (params: ValidateAndSignECDSA) => Promise<string>;
    /** ============================== SESSION ============================== */
    /**
     * Sign a session public key using a PKP, which generates an authSig.
     * @returns {Object} An object containing the resulting signature.
     */
    signSessionKey: (params: SignSessionKeyProp) => Promise<SignSessionKeyResponse>;
    getSignSessionKeyShares: (url: string, params: GetSignSessionKeySharesProp, requestId: string) => Promise<any>;
    generateAuthMethodForWebAuthn: (params: WebAuthnAuthenticationVerificationParams) => AuthMethod;
    generateAuthMethodForDiscord: (access_token: string) => AuthMethod;
    generateAuthMethodForGoogle: (access_token: string) => AuthMethod;
    generateAuthMethodForGoogleJWT: (access_token: string) => AuthMethod;
    /**
     * Get session signatures for a set of resources
     *
     * High level, how this works:
     * 1. Generate or retrieve session key
     * 2. Generate or retrieve the wallet signature of the session key
     * 3. Sign the specific resources with the session key
     *
     * Note: When generating session signatures for different PKPs or auth methods,
     * be sure to call disconnectWeb3 to clear auth signatures stored in local storage
     *
     * @param { GetSessionSigsProps } params
     */
    getSessionSigs: (params: GetSessionSigsProps) => Promise<SessionSigsMap>;
    /**
     *
     * Get Session Key URI eg. lit:session:0x1234
     *
     * @param publicKey is the public key of the session key
     * @returns { string } the session key uri
     */
    getSessionKeyUri: (publicKey: string) => string;
}
