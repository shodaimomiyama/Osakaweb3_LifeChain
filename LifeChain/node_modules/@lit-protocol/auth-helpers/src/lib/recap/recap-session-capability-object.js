"use strict";
var _RecapSessionCapabilityObject_instances, _RecapSessionCapabilityObject_inner, _RecapSessionCapabilityObject_getResourceKeyToMatchAgainst;
Object.defineProperty(exports, "__esModule", { value: true });
exports.RecapSessionCapabilityObject = void 0;
const tslib_1 = require("tslib");
const siwe_recap_1 = require("siwe-recap");
const utils_1 = require("./utils");
const siwe_1 = require("../siwe");
class RecapSessionCapabilityObject {
    constructor(att = {}, prf = []) {
        _RecapSessionCapabilityObject_instances.add(this);
        _RecapSessionCapabilityObject_inner.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _RecapSessionCapabilityObject_inner, new siwe_recap_1.Recap(att, prf), "f");
    }
    static decode(encoded) {
        const recap = siwe_recap_1.Recap.decode_urn(encoded);
        return new this(recap.attenuations, recap.proofs.map((cid) => cid.toString()));
    }
    static extract(siwe) {
        const recap = siwe_recap_1.Recap.extract_and_verify(siwe);
        return new this(recap.attenuations, recap.proofs.map((cid) => cid.toString()));
    }
    get attenuations() {
        return tslib_1.__classPrivateFieldGet(this, _RecapSessionCapabilityObject_inner, "f").attenuations;
    }
    get proofs() {
        return tslib_1.__classPrivateFieldGet(this, _RecapSessionCapabilityObject_inner, "f").proofs.map((cid) => cid.toString());
    }
    get statement() {
        return (0, siwe_1.sanitizeSiweMessage)(tslib_1.__classPrivateFieldGet(this, _RecapSessionCapabilityObject_inner, "f").statement);
    }
    addProof(proof) {
        return tslib_1.__classPrivateFieldGet(this, _RecapSessionCapabilityObject_inner, "f").addProof(proof);
    }
    addAttenuation(resource, namespace = '*', name = '*', restriction = {}) {
        return tslib_1.__classPrivateFieldGet(this, _RecapSessionCapabilityObject_inner, "f").addAttenuation(resource, namespace, name, restriction);
    }
    addToSiweMessage(siwe) {
        return tslib_1.__classPrivateFieldGet(this, _RecapSessionCapabilityObject_inner, "f").add_to_siwe_message(siwe);
    }
    encodeAsSiweResource() {
        return tslib_1.__classPrivateFieldGet(this, _RecapSessionCapabilityObject_inner, "f").encode();
    }
    /** LIT specific methods */
    addCapabilityForResource(litResource, ability) {
        // Validate Lit ability is compatible with the Lit resource.
        if (!litResource.isValidLitAbility(ability)) {
            throw new Error(`The specified Lit resource does not support the specified ability.`);
        }
        const { recapNamespace, recapAbility } = (0, utils_1.getRecapNamespaceAndAbility)(ability);
        return this.addAttenuation(litResource.getResourceKey(), recapNamespace, recapAbility);
    }
    verifyCapabilitiesForResource(litResource, ability) {
        // Validate Lit ability is compatible with the Lit resource.
        // The only exception is if there's a wildcard resource key in the session capability object.
        if (!litResource.isValidLitAbility(ability)) {
            return false;
        }
        // Get the attenuations object.
        const attenuations = this.attenuations;
        const { recapNamespace, recapAbility } = (0, utils_1.getRecapNamespaceAndAbility)(ability);
        const recapAbilityToCheckFor = `${recapNamespace}/${recapAbility}`;
        // Find an attenuated resource key to match against.
        const attenuatedResourceKey = tslib_1.__classPrivateFieldGet(this, _RecapSessionCapabilityObject_instances, "m", _RecapSessionCapabilityObject_getResourceKeyToMatchAgainst).call(this, litResource);
        if (!attenuations[attenuatedResourceKey]) {
            // No attenuations specified for this resource.
            return false;
        }
        // Check whether the exact Recap namespace/ability pair is present.
        const attenuatedRecapAbilities = Object.keys(attenuations[attenuatedResourceKey]);
        for (const attenuatedRecapAbility of attenuatedRecapAbilities) {
            // Return early if the attenuated recap ability is a wildcard.
            if (attenuatedRecapAbility === '*/*') {
                return true;
            }
            if (attenuatedRecapAbility === recapAbilityToCheckFor) {
                return true;
            }
        }
        return false;
    }
    addAllCapabilitiesForResource(litResource) {
        return this.addAttenuation(litResource.getResourceKey(), '*', '*');
    }
}
exports.RecapSessionCapabilityObject = RecapSessionCapabilityObject;
_RecapSessionCapabilityObject_inner = new WeakMap(), _RecapSessionCapabilityObject_instances = new WeakSet(), _RecapSessionCapabilityObject_getResourceKeyToMatchAgainst = function _RecapSessionCapabilityObject_getResourceKeyToMatchAgainst(litResource) {
    const attenuatedResourceKeysToMatchAgainst = [
        `${litResource.resourcePrefix}://*`,
        litResource.getResourceKey(),
    ];
    for (const attenuatedResourceKeyToMatchAgainst of attenuatedResourceKeysToMatchAgainst) {
        if (this.attenuations[attenuatedResourceKeyToMatchAgainst]) {
            return attenuatedResourceKeyToMatchAgainst;
        }
    }
    return '';
};
//# sourceMappingURL=recap-session-capability-object.js.map